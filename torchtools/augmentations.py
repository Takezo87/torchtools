# AUTOGENERATED! DO NOT EDIT! File to edit: 20_augmentations.ipynb (unless otherwise specified).

__all__ = ['noise_from_random_curve', 'noise_from_normal', 'distort_time', 'AugTransform', 'YWarp', 'YNormal', 'YScale',
           'TimeWarp', 'TimeNormal', 'RandAugment']

# Cell
import random
from functools import partial
from scipy.interpolate import CubicSpline
from .data import *

# Cell
import numpy as np
import torch

from fastai2.torch_basics import *
from fastai2.data.all import *

from .data import *

# Cell
#oguiza implementation, only used for _magwarp
# def random_curve_generator(ts, magnitude=.1, order=4, noise=None):
#     '''
#     sample points from a gaussian with mean 1 and create a smooth cubic "random curve" from these points
#     '''
#     seq_len = ts.shape[-1]
#     x = np.linspace(-seq_len, 2 * seq_len - 1, 3 * (order - 1) + 1, dtype=int)
#     x2 = np.random.normal(loc=1.0, scale=magnitude, size=len(x))
#     f = CubicSpline(x, x2, axis=-1)
#     return f(np.arange(seq_len))

# Cell

def _create_random_curve(n_channels, seq_len, magnitude, order):
    '''
    create a random curve for each channel in the interval[0, seq_len-1] on order random points
    '''
    x = np.linspace(0, seq_len-1, order)
    y = np.random.normal(loc=1.0, scale=magnitude, size=(n_channels, len(x)))
    f = CubicSpline(x, y, axis=-1)
    return f

def noise_from_random_curve(dim, magnitude=.1, order=4):
    '''
    sample points from a gaussian with mean 1 and create a smooth cubic "random curve" from these points
    ts, needs to be 2D
    order: number of sample to create the random curve from
    '''
    n_channels, seq_len = dim
    f = _create_random_curve(n_channels, seq_len, magnitude, order)
    return torch.tensor(f(np.arange(seq_len)))

def noise_from_normal(dim, magnitude=.1):
    '''
    sample random noise from a gaussian with mean=1.0 and std=magnitude
    '''
    n_channels, seq_len = dim
    return torch.tensor(np.random.normal(loc=1.0, scale=magnitude, size=(n_channels, seq_len)))

# Cell
def _ynoise(x, magnitude=.1, add=True, smooth=True, **kwargs):
    '''
    add random noise to timeseries values
    '''
#     assert isinstance(x, Tensor)
    assert len(x.shape)==2 or len(x.shape)==3, 'tensor needs to be 2D or 3D'
    if magnitude <= 0: return x
    n_channels, seq_len = x.shape[-2], x.shape[-1]
    noise_fn = noise_from_random_curve if smooth else noise_from_normal

    noise = noise_fn((n_channels, seq_len), magnitude=magnitude, **kwargs).to(x.device)
    if add:
        output = x + (noise-1)
        return output.to(x.device, x.dtype)
    else:
        output = x * (noise)
        return output.to(x.device, x.dtype)

# Cell
_ynoise_warp = partial(_ynoise, smooth=True)
_ynoise_normal = partial(_ynoise, smooth=False)

# Cell
def _yscale(x, magnitude=.1, normal=False):
    if magnitude <= 0: return x
    if normal:
        scale = 1.+(torch.randn(1))*magnitude
    else:
        scale = 1 + torch.rand(1) * magnitude  # uniform [0:1], normal possible
        if np.random.rand() < .5: scale = 1 / scale # scale down
    output = x * scale.to(x.device)
    return output

# Cell
def _normalize_timesteps(timesteps):
    '''
    distorted timesteps in [0,..,seq_len]
    '''
#     timesteps = timesteps - np.expand_dims(timesteps[:,0], -1)
#     timesteps = timesteps.clone()
    timesteps = timesteps.sub(timesteps[:,0].unsqueeze(-1))

#     timesteps = timesteps/np.expand_dims(timesteps[:,-1], -1) * (timesteps.shape[1]-1)
    timesteps=timesteps.div(timesteps[:,-1].unsqueeze(-1)) * (timesteps.shape[1]-1)

    return timesteps


def distort_time(dim, magnitude=.1, smooth=False, **kwargs):
    '''
    distort the time steps (x-axis) of timeseries
    '''
    n_channels, seq_len = dim
    noise_fn = noise_from_random_curve if smooth else noise_from_normal
    noise = noise_fn((n_channels, seq_len), magnitude=magnitude, **kwargs)
    time_new = _normalize_timesteps(noise.cumsum(1))
#     noise_cum = noise_cum - np.expand_dims(noise_cum[:,0], -1)
#     noise_cum = noise_cum/np.expand_dims(noise_cum[:,-1], -1) * (ts.shape[1]-1)
#     x /= x[-1]
#     x = np.clip(x, 0, 1)
#     print(x)
#     return x * (ts.shape[-1] - 1)
    return time_new

# Cell
def _timenoise(x, magnitude=.1, smooth=False, **kwargs):
    '''This is a slow batch tfm on cpu'''
    if magnitude <= 0: return x
#     if len(x.shape)==1: x=x.unsqueeze(0) #no support for 1D tensors
    assert len(x.shape)==2 or len(x.shape)==3, 'tensor needs to be 2D or 3D'
    n_channels, seq_len = x.shape[-2], x.shape[-1]
    x_device = x.device ## make sure to put outpout on right device
    x=x.cpu() ## only works on cpu

#    return f
#     plt.plot(x.T)
#     plt.plot(np.linspace(0,10), f(np.linspace(0,10)[:, None]).squeeze())
    new_x = distort_time((n_channels,seq_len), magnitude=magnitude, smooth=True, **kwargs).to(x.device)
    fs = [CubicSpline(np.arange(seq_len), x[...,i,:], axis=-1) for i in range(n_channels)]
#     new_y = f(new_x, )
#     print(fs(new_x).shape)
#     return new_x
    new_y = torch.stack([torch.tensor(fs[i](xi)) for i,xi in enumerate(new_x)])
    if len(x.shape)==3: new_y = new_y.permute(1,0,2)

    return new_y.to(x_device, x.dtype)

# Cell
def _timewarp(x, magnitude=.1, order=4):
    return _timenoise(x, magnitude, smooth=True, order=order)
def _timenormal(x, magnitude=.1):
    return _timenoise(x, magnitude, smooth=False)

# Cell
@delegates(Transform.__init__)
class AugTransform(Transform):
    split_idx=0
    def __init__(self, magnitude=0.1, **kwargs):
        super().__init__(**kwargs)
        self.magnitude=magnitude

    def __call__(self, x, split_idx=split_idx):
        return super().__call__(x, split_idx=split_idx)

# Cell
@delegates()
class YWarp(AugTransform):
    order=200
    def encodes(self, x:TSTensor):
        print('ywarp')
        return _ynoise_warp(x, magnitude=self.magnitude)

# Cell
class YNormal(AugTransform):
    order=200
    def encodes(self, x:TSTensor):
        print('ynormal')
        return _ynoise_normal(x)

# Cell
class YScale(AugTransform):
    order=200
    def encodes(self, x:TSTensor):
        print('yscale')
        return _yscale(x)

# Cell
class TimeWarp(AugTransform):
    order=200
    def encodes(self, x:TSTensor):
        print('timewarp')
        return _timewarp(x)

# Cell
class TimeNormal(AugTransform):
    order=200
    def encodes(self, x:TSTensor):
        print('timenormal')
        return _timenormal(x, magnitude=self.magnitude)

# Cell
def _all_noise_augs(magnitude=0.1):
    return [YWarp(magnitude=magnitude), YNormal(magnitude=magnitude), YScale(magnitude=magnitude),
           TimeWarp(magnitude=magnitude), TimeNormal(magnitude=magnitude)]

# Cell
class RandAugment(AugTransform):
    def __init__(self, N=2, magnitude=0.2, tfms=None, **kwargs):
        super().__init__(**kwargs)
        self.N = N
        if tfms is None: self.tfms = _all_noise_augs(magnitude)

    def encodes(self, x:TSTensor):
        fs = np.random.choice(self.tfms, 2, replace=False)
        return compose_tfms(x, fs)
